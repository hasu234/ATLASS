[
    {
        "name": "Alpha_Vantage_Stock_API_Tool",
        "description": "A tool to fetch historical stock price data from Alpha Vantage API for the specified ticker symbol (Meta) and time period (last 10 days), including open, high, low, close, and adjusted close prices.",
        "is_available": true,
        "function": "import requests\n\ndef get_time_series_daily(symbol, apikey):\n    base_url = \"https://www.alphavantage.co/query\"\n    params = {\n        \"function\": \"TIME_SERIES_DAILY\",\n        \"symbol\": symbol,\n        \"apikey\": apikey\n    }\n    response = requests.get(base_url, params=params)\n    return response.json()\n\ndef get_time_series_daily_csv(symbol, apikey):\n    base_url = \"https://www.alphavantage.co/query\"\n    params = {\n        \"function\": \"TIME_SERIES_DAILY\",\n        \"symbol\": symbol,\n        \"apikey\": apikey,\n        \"datatype\": \"csv\"\n    }\n    response = requests.get(base_url, params=params)\n    return response.text\n\n# Example usage:\nsymbol = \"IBM\"\napikey = \"YOUR_API_KEY_HERE\"\n\ndaily_data = get_time_series_daily(symbol, apikey)\nprint(daily_data)\n\ndaily_csv = get_time_series_daily_csv(symbol, apikey)\nprint(daily_csv)"
    },
    {
        "name": "OpenWeatherMap_API_Tool",
        "description": "A tool to fetch current weather data from OpenWeatherMap API, including temperature, humidity, and conditions for a specified city, in this case, New York City.",
        "is_available": true,
        "function": "import requests\nimport json\n\ndef get_current_weather(api_key, city):\n    base_url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n    response = requests.get(base_url)\n    weather_data = response.json()\n    return weather_data\n\ndef get_historical_weather(api_key, city, start_date, end_date):\n    base_url = f\"http://api.openweathermap.org/data/2.5/onecall/timemachine?lat={city['lat']}&lon={city['lon']}&dt={start_date}&appid={api_key}\"\n    response = requests.get(base_url)\n    historical_weather_data = response.json()\n    return historical_weather_data\n\ndef get_solar_irradiance(api_key, city):\n    base_url = f\"http://api.openweathermap.org/data/2.5/solar_irradiance?lat={city['lat']}&lon={city['lon']}&appid={api_key}\"\n    response = requests.get(base_url)\n    solar_irradiance_data = response.json()\n    return solar_irradiance_data\n\ndef get_weather_maps(api_key, city):\n    base_url = f\"http://api.openweathermap.org/data/2.5/weather_map?lat={city['lat']}&lon={city['lon']}&appid={api_key}\"\n    response = requests.get(base_url)\n    weather_maps_data = response.json()\n    return weather_maps_data\n\ndef main():\n    api_key = \"YOUR_API_KEY\"\n    city = {\"lat\": 37.7749, \"lon\": -122.4194}\n    \n    current_weather = get_current_weather(api_key, \"San Francisco\")\n    print(json.dumps(current_weather, indent=4))\n    \n    historical_weather = get_historical_weather(api_key, city, 1643723400, 1646315200)\n    print(json.dumps(historical_weather, indent=4))\n    \n    solar_irradiance = get_solar_irradiance(api_key, city)\n    print(json.dumps(solar_irradiance, indent=4))\n    \n    weather_maps = get_weather_maps(api_key, city)\n    print(json.dumps(weather_maps, indent=4))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "name": "Football_Player_Popularity_API_Tool",
        "description": "A tool to fetch data from a sports API (e.g., ESPN API, Sports-Reference API) and calculate the most famous football player based on metrics such as awards won, social media following, endorsement deals, and on-field performance.",
        "is_available": true,
        "function": "import requests\nimport json\n\n# Define API endpoint URLs\nespn_api_url = \"https://site.api.espn.com/apis/site/v2/sports/football/nfl/athletes\"\nespn_awards_url = \"https://site.api.espn.com/apis/site/v2/sports/football/nfl/awards\"\n\n# Authenticate with the API using placeholder values for keys/tokens\napi_key = \"YOUR_API_KEY\"\napi_secret = \"YOUR_API_SECRET\"\nauth_headers = {\n    \"Authorization\": f\"Bearer {api_key}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef get_athletes():\n    # Make API call to fetch athletes data\n    response = requests.get(espn_api_url, headers=auth_headers)\n    \n    # Check if the request was successful\n    if response.status_code == 200:\n        return json.loads(response.text)\n    else:\n        print(f\"Failed to retrieve athletes data: {response.status_code}\")\n        return None\n\ndef get_awards(athlete_id):\n    # Make API call to fetch awards data for a specific athlete\n    awards_url = f\"{espn_awards_url}/{athlete_id}\"\n    response = requests.get(awards_url, headers=auth_headers)\n    \n    # Check if the request was successful\n    if response.status_code == 200:\n        return json.loads(response.text)\n    else:\n        print(f\"Failed to retrieve awards data for athlete {athlete_id}: {response.status_code}\")\n        return None\n\ndef calculate_fame(athletes):\n    # Define metrics and their weights\n    metrics = {\n        \"awards\": 0.3,\n        \"social_media_following\": 0.2,\n        \"endorsement_deals\": 0.2,\n        \"on_field_performance\": 0.3\n    }\n    \n    # Initialize a dictionary to store the fame score for each athlete\n    fame_scores = {}\n    \n    # Iterate through athletes and calculate their fame scores\n    for athlete in athletes:\n        awards_data = get_awards(athlete[\"id\"])\n        if awards_data is not None:\n            awards_count = len(awards_data[\"awards\"])\n        else:\n            awards_count = 0\n        \n        # Replace with actual social media following data (e.g., from Twitter API)\n        social_media_following = athlete.get(\"socialMedia\", {}).get(\"followers\", 0)\n        \n        # Replace with actual endorsement deals data\n        endorsement_deals = athlete.get(\"endorsementDeals\", 0)\n        \n        # Replace with actual on-field performance data (e.g., from NFL API)\n        on_field_performance = athlete.get(\"stats\", {}).get(\"yards\", 0)\n        \n        fame_score = (\n            metrics[\"awards\"] * awards_count +\n            metrics[\"social_media_following\"] * social_media_following +\n            metrics[\"endorsement_deals\"] * endorsement_deals +\n            metrics[\"on_field_performance\"] * on_field_performance\n        )\n        fame_scores[athlete[\"name\"]] = fame_score\n    \n    return fame_scores\n\ndef find_most_famous_player():\n    athletes_data = get_athletes()\n    \n    if athletes_data is not None:\n        fame_scores = calculate_fame(athletes_data)\n        \n        # Find the athlete with the highest fame score\n        most_famous_player = max(fame_scores, key=fame_scores.get)\n        print(f\"The most famous football player is: {most_famous_player}\")\n    else:\n        print(\"Failed to retrieve athletes data\")\n\n# Example usage\nfind_most_famous_player()"
    },
    {
        "name": "Google_Trends_API_Tool",
        "description": "A tool to fetch current trend data from Google Trends API, specifically focusing on football players, and determine the most popular one based on search volume and recent activity.",
        "is_available": true,
        "function": "import os\nfrom pytrends import TrendReq\nfrom datetime import datetime, timedelta\n\n# Set up API credentials (replace with your own)\nAPI_KEY = \"YOUR_API_KEY\"\nAPI_SECRET = \"YOUR_API_SECRET\"\n\ndef get_most_popular_football_player():\n    # Initialize the PyTrends object\n    pytrends = TrendReq(api_key=API_KEY, api_secret=API_SECRET)\n\n    # Define the football players to compare\n    football_players = [\"Cristiano Ronaldo\", \"Lionel Messi\", \"Kylian Mbapp\u00e9\"]\n\n    # Create a dictionary to store the search volume for each player\n    search_volumes = {}\n\n    # Loop through each football player and get their search volume\n    for player in football_players:\n        # Build the payload for the API request\n        payload = {\n            \"q\": player,\n            \"cat\": \"0\",  # All categories\n            \"geo\": \"\",  # All regions\n            \"gprop\": \"\",  # All properties\n            \"date\": (datetime.today() - timedelta(days=30)).strftime(\"%Y-%m-%d\") + \" \" + datetime.today().strftime(\"%Y-%m-%d\")\n        }\n\n        # Make the API request to get the search volume\n        pytrends.build_payload(kw_list=[player], cat=0, timeframe=(datetime.today() - timedelta(days=30)).strftime(\"%Y-%m-%d\") + \" \" + datetime.today().strftime(\"%Y-%m-%d\"), geo=\"\", gprop=\"\")\n        interest_over_time_df = pytrends.interest_over_time()\n\n        # Get the average search volume for the player\n        if not interest_over_time_df.empty:\n            avg_search_volume = interest_over_time_df[player].mean()\n            search_volumes[player] = avg_search_volume\n\n    # Find the football player with the highest search volume\n    most_popular_player = max(search_volumes, key=search_volumes.get)\n\n    return most_popular_player\n\n# Call the function to get the most popular football player\nmost_popular_player = get_most_popular_football_player()\n\nprint(\"The most popular football player is:\", most_popular_player)"
    },
    {
        "name": "Basic_Arithmetic_Calculator_Tool",
        "description": "A tool to perform basic arithmetic operations, taking two numbers and an operator as input, and returning the result of the operation.",
        "is_available": true,
        "function": "import sys\nimport subprocess\nimport pkg_resources\nfrom typing import Annotated\n\nREQUIRED_PACKAGES = [\n    're',  # For regular expression operations\n]\n\nfor package in REQUIRED_PACKAGES:\n    try:\n        dist = pkg_resources.get_distribution(package)\n    except pkg_resources.DistributionNotFound:\n        subprocess.call([sys.executable, '-m', 'pip', 'install', package])\n\nimport re\n\ndef extract_numbers_and_operator(user_query: Annotated[str, \"The user's query containing numbers and an operator\"]) -> Annotated[tuple[int, str, int], \"A tuple containing the two numbers and the operator\"]:\n    \"\"\"\n    Extracts two numbers and an operator from a user query.\n\n    Args:\n        user_query (str): The user's query containing numbers and an operator.\n\n    Returns:\n        tuple[int, str, int]: A tuple containing the two numbers and the operator.\n    \"\"\"\n\n    # Regular expression pattern to match numbers and operators\n    pattern = r\"(\\d+)\\s*([+-/*])\\s*(\\d+)\"\n    \n    # Search for a match in the user query\n    match = re.search(pattern, user_query)\n    \n    if match:\n        num1, operator, num2 = match.groups()\n        return int(num1), operator, int(num2)\n    else:\n        raise ValueError(\"Invalid user query. Please provide a query with two numbers and an operator.\")\n\ndef perform_arithmetic_operation(num1: Annotated[int, \"The first number\"], operator: Annotated[str, \"The operator\"], num2: Annotated[int, \"The second number\"]) -> Annotated[float, \"The result of the operation\"]:\n    \"\"\"\n    Performs an arithmetic operation based on the provided operator.\n\n    Args:\n        num1 (int): The first number.\n        operator (str): The operator.\n        num2 (int): The second number.\n\n    Returns:\n        float: The result of the operation.\n    \"\"\"\n\n    if operator == '+':\n        return num1 + num2\n    elif operator == '-':\n        return num1 - num2\n    elif operator == '*':\n        return num1 * num2\n    elif operator == '/':\n        if num2 != 0:\n            return num1 / num2\n        else:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n    else:\n        raise ValueError(f\"Unsupported operation: {operator}\")\n\ndef main(user_query: Annotated[str, \"The user's query containing numbers and an operator\"]) -> None:\n    \"\"\"\n    Main function to perform arithmetic operations based on the user query.\n\n    Args:\n        user_query (str): The user's query containing numbers and an operator.\n    \"\"\"\n\n    try:\n        num1, operator, num2 = extract_numbers_and_operator(user_query)\n        result = perform_arithmetic_operation(num1, operator, num2)\n        print(f\"The result of the operation is: {result}\")\n    except Exception as e:\n        print(f\"An error occurred: {str(e)}\")\n\nif __name__ == \"__main__\":\n    user_query = 'what is 5 + 12?'\n    main(user_query)"
    },
    {
        "name": "Stock_Price_Visualizer_Tool",
        "description": "A comprehensive tool using matplotlib library to process and visualize the fetched stock price data, creating a line chart of price trends over time.",
        "is_available": true,
        "function": "import sys\nimport subprocess\nimport pkg_resources\nfrom typing import Annotated\nfrom datetime import datetime, timedelta\nimport yfinance as yf\nimport matplotlib.pyplot as plt\n\nREQUIRED_PACKAGES = [\n    'yfinance',  # Required for fetching stock data\n    'matplotlib'  # Required for creating visualizations\n]\n\nfor package in REQUIRED_PACKAGES:\n    try:\n        dist = pkg_resources.get_distribution(package)\n    except pkg_resources.DistributionNotFound:\n        subprocess.call([sys.executable, '-m', 'pip', 'install', package])\n\ndef fetch_stock_data(ticker: Annotated[str, \"Stock ticker symbol\"], days: Annotated[int, \"Number of days\"]) -> Annotated[dict, \"Dictionary containing stock data\"]:\n    \"\"\"\n    Fetches the historical stock price data for a given ticker symbol.\n\n    Args:\n        ticker (str): The stock ticker symbol.\n        days (int): The number of days to fetch data for.\n\n    Returns:\n        dict: A dictionary containing the stock data.\n    \"\"\"\n    end_date = datetime.today().strftime('%Y-%m-%d')\n    start_date = (datetime.today() - timedelta(days=days)).strftime('%Y-%m-%d')\n    data = yf.download(ticker, start=start_date, end=end_date)\n    return data\n\ndef visualize_stock_data(data: Annotated[dict, \"Dictionary containing stock data\"], ticker: Annotated[str, \"Stock ticker symbol\"]) -> None:\n    \"\"\"\n    Creates a line chart visualization of the stock price data.\n\n    Args:\n        data (dict): A dictionary containing the stock data.\n        ticker (str): The stock ticker symbol.\n    \"\"\"\n    plt.figure(figsize=(10, 5))\n    plt.plot(data.index, data['Close'], label=f'{ticker} Stock Price')\n    plt.title(f'{ticker} Stock Price Trend')\n    plt.xlabel('Date')\n    plt.ylabel('Price (USD)')\n    plt.legend()\n    plt.grid(True)\n    plt.savefig(f'{ticker}_stock_price_trend.png')\n\ndef main() -> None:\n    \"\"\"\n    Main function to execute the stock price visualizer tool.\n    \"\"\"\n    user_query = 'Get the last 10 days stock price of Meta and visualize it.'\n    ticker = 'META'  # Extracted from user query\n    days = 10  # Extracted from user query\n\n    try:\n        data = fetch_stock_data(ticker, days)\n        visualize_stock_data(data, ticker)\n        print(f\"Stock price data for {ticker} has been visualized and saved to {ticker}_stock_price_trend.png\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "name": "Email_Extractor_Tool",
        "description": "A tool to scan input text, identify email address patterns using regex, and extract all valid email addresses.",
        "is_available": true,
        "function": "import sys\nimport subprocess\nimport pkg_resources\nfrom typing import Annotated\nimport re\n\nREQUIRED_PACKAGES = [\n    'regex',  # Not a real package, using built-in re instead\n]\n\nfor package in REQUIRED_PACKAGES:\n    try:\n        dist = pkg_resources.get_distribution(package)\n    except pkg_resources.DistributionNotFound:\n        subprocess.call([sys.executable, '-m', 'pip', 'install', package])\n\ndef extract_email_addresses(text: Annotated[str, \"Input text to scan for email addresses\"]) -> Annotated[list[str], \"List of extracted email addresses\"]:\n    \"\"\"\n    Extracts all valid email addresses from the given input text.\n\n    Args:\n        text (str): The input text to scan for email addresses.\n\n    Returns:\n        list[str]: A list of extracted email addresses.\n    \"\"\"\n\n    # Regular expression pattern for matching email addresses\n    email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n\n    try:\n        # Use the regular expression to find all matches in the input text\n        email_addresses = re.findall(email_pattern, text)\n        \n        return email_addresses\n    \n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return []\n\ndef main() -> None:\n    \"\"\"\n    Main function to solve the user query.\n    \"\"\"\n\n    # Get the input text from the user query\n    input_text = \"Contact us at support@example.com or sales@example.org for more information.\"\n\n    # Extract email addresses from the input text\n    email_addresses = extract_email_addresses(input_text)\n\n    # Print the extracted email addresses\n    print(\"Extracted Email Addresses:\")\n    for email in email_addresses:\n        print(email)\n\nif __name__ == \"__main__\":\n    main()"
    }
]